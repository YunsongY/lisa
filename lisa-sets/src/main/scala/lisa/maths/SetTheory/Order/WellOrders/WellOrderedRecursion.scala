package lisa.maths.SetTheory.Order
package WellOrders

import lisa.maths.SetTheory.Base.Predef.{*, given}
import lisa.maths.SetTheory.Relations
import lisa.maths.SetTheory.Relations.WellFoundedRelation.wellFounded
import lisa.maths.SetTheory.Functions
import lisa.maths.SetTheory.Functions.Predef.*
import lisa.maths.Quantifiers
import lisa.maths.Quantifiers.‚àÉ!

import Extrema.*
import PartialOrder.*
import WellOrder.*
import InitialSegment.*

/**
  * This file is dedicated to proving the well-ordered recursion theorem:
  * Given a well-order `(A, <)`, one can build a function `G` by recursion over
  * `A` that satisfies the following formula:
  *
  *   `G(x) = F(x, G‚ÜæinitialSegment(x, A, <))` for all `x ‚àà A`
  *
  * where `F : V √ó V -> V` is a class function, and `initialSegment(x, A, <) = {y ‚àà A | y < x}`.
  */
object WellOrderedRecursion extends lisa.Main {

  private val F = variable[Set >>: Set >>: Set]
  private val G, G1, G2 = variable[Set]
  private val S = variable[Set]
  private val p = variable[Set]
  private val ùìï = variable[Set]

  extension (f: Expr[Set]) {
    private def apply(x: Expr[Set]): Expr[Set] = app(f)(x)
  }

  /**
    * The proof is divided into 2 parts: uniqueness and existence.
    *
    * Uniqueness ([[uniqueness]]): follows from well-foundedness of
    * `(A, <)`, from a minimal counterexample to `G1(x) = G2(x)`.
    *
    * Existence ([[existence]]):
    *
    * 1. ([[recursion]])
    *    We first construct a unique approximation `G_x` with domain `A_<x`
    *    for all `x ‚àà A`. Namely, we show that
    *
    *      `‚àÄx ‚àà A. ‚àÉ!G_x. ‚àÄy < x. G_x(y) = F(y, G_x ‚Üæ initialSegment(y, A, <))`
    *
    *    We show unique existence by well-ordered induction: given that there exists
    *    unique approximations `G_y` for all `y < x`, we construct an approximation
    *    `G_x` until `x`, and show that it is unique ([[recursionStep]]).
    *
    *    The approximation `G_x` is constructed as follows ([[recursionStepExistence]]):
    *
    *      Sucessor case ([[successorCase]]):
    *       If `x` has a predecessor `p`, set `G_x = G_p ‚à™ {(p, F(p, G_p))}`.
    *       Hence `G_x` is an extension of `G_p` with domain `dom(G_x) = A_<p ‚à™
    *       {p} = A_<x`.
    *
    *      Limit case ([[limitCase]]):
    *       If `x` has no predecessors (i.e. `x` is limit), set `G_x = ‚ãÉ{G_y | y
    *       < x}`. `G_x` is a function by virtue of the fact that any two
    *       approximations `G_y` and `G_z` are coherent on the intersection of
    *       their domains ([[coherence]]).
    *
    *    The uniqueness proof for `G_x` is similar to the uniqueness proof above
    *    ([[recursionStepUniqueness]]).
    *
    * 2. ([[existence]])
    *    To define the function over `A`, we take `G = ‚ãÉ{G_x | x ‚àà A}`, and we show
    *    that it is a function, in a similar fashion as in 1.b (using [[coherence]]).
    *    If there is a maximal element `m ‚àà A`, we take `G' = G ‚à™ {(m, F(m, G))}` instead.
    */


  //////////////////////////////////////////////////////////////
  section("Uniqueness")


  /**
   * Well-ordered recursion function is unique --- If `G1 : A -> V` and `G2 : A -> V`
   * satisfy the recursion equations, then `G1 = G2`.
    *
    * *Proof*:
    *
    * The proof goes by *minimal counter-example*: consider the set
    *
    *   `D = {x ‚àà X | G1(x) ‚â† G2(x)}`
    *
    * Assume towards a contradiction that `D ‚â† ‚àÖ`. Then there exists a
    * `<`-minimal element `x ‚àà D` such that
    *
    *   `G1(x) ‚â† G2(x)` and `G1(y) = G2(y)` for all `y < x`.
    *
    * But this implies that `G1 ‚Üæ A_<x = G2 ‚Üæ A_<x` and hence by definition
    *
    *   `G1(x) = F(x, G1 ‚Üæ A_<x) = F(x, G2 ‚Üæ A_<x) = G2(x)`,
    *
    * Contradiction.
    */
  val uniqueness = Theorem(
    (
      wellOrder(A)(<),
      functionOn(G1)(A),
      functionOn(G2)(A),
      ‚àÄ(x ‚àà A, G1(x) === F(x)(G1 ‚Üæ initialSegment(x)(A)(<))),
      ‚àÄ(x ‚àà A, G2(x) === F(x)(G2 ‚Üæ initialSegment(x)(A)(<)))
    ) |- ‚àÄ(x ‚àà A, G1(x) === G2(x))
  ) {
    assume(wellOrder(A)(<))

    assume(functionOn(G1)(A))
    assume(‚àÄ(x ‚àà A, G1(x) === F(x)(G1 ‚Üæ initialSegment(x)(A)(<))))
    val `G1(x)` = thenHave(x ‚àà A |- G1(x) === F(x)(G1 ‚Üæ initialSegment(x)(A)(<))) by InstantiateForall(x)

    assume(functionOn(G2)(A))
    assume(‚àÄ(x ‚àà A, G2(x) === F(x)(G2 ‚Üæ initialSegment(x)(A)(<))))
    val `G2(x)` = thenHave(x ‚àà A |- G2(x) === F(x)(G2 ‚Üæ initialSegment(x)(A)(<))) by InstantiateForall(x)

    // Consider the set D = { x ‚àà A | G1(x) ‚â† G2(x) }
    val D = { x ‚àà A | G1(x) ‚â† G2(x) }
    val `x ‚àà D` = have(x ‚àà D <=> x ‚àà A /\ (G1(x) ‚â† G2(x))) by Comprehension.apply

    // Assume towards a contradiction that D ‚â† ‚àÖ
    have(D ‚â† ‚àÖ |- ‚ä•) subproof {
      assume(D ‚â† ‚àÖ)

      // Let `x ‚àà D` be the `<`-minimal element of D.
      // We have that G1 and G2 agree on initialSegment(x, A, <)
      have(minimal(x)(D)(<) |- (G1 ‚Üæ initialSegment(x)(A)(<)) === (G2 ‚Üæ initialSegment(x)(A)(<))) subproof {
        assume(minimal(x)(D)(<))

        have(‚àÄ(y ‚àà D, ¬¨(y < x))) by Tautology.from(minimal.definition of (a := x, A := D))
        thenHave(y ‚àà D ==> ¬¨(y < x)) by InstantiateForall(y)
        thenHave(y ‚àà initialSegment(x)(A)(<) ==> (G1(y) === G2(y))) by Tautology.fromLastStep(
          `x ‚àà D` of (x := y),
          InitialSegment.membership
        )
        thenHave(‚àÄ(y ‚àà initialSegment(x)(A)(<), G1(y) === G2(y))) by RightForall
        thenHave(thesis) by Tautology.fromLastStep(
          Restriction.extensionality of (A := initialSegment(x)(A)(<), f := G1, g := G2),
          Functions.BasicTheorems.functionOnIsFunction of (f := G1),
          Functions.BasicTheorems.functionOnIsFunction of (f := G2),
        )
      }

      // By definition of G1(x) and G2(x), this means that G1(x) === G2(x)
      have(minimal(x)(D)(<) |- G1(x) === G2(x)) by Congruence.from(
        lastStep,
        `G1(x)`,
        `G2(x)`,
      )

      // Contradiction since x ‚àà D implies G1(x) ‚â† G2(x)
      thenHave(minimal(x)(D)(<) |- ()) by Tautology.fromLastStep(
        minimal.definition of (a := x, A := D),
        `x ‚àà D`
      )
      thenHave(‚àÉ(x, minimal(x)(D)(<)) |- ()) by LeftExists

      // Conclude by well-foundedness
      thenHave(thesis) by Tautology.fromLastStep(
        wellOrder.definition,
        WellFoundedRelation.minimalElement of (R := <, S := D, X := A),
        Comprehension.subset of (y := A, œÜ := Œª(x, G1(x) ‚â† G2(x)))
      )
    }

    // Therefore D = ‚àÖ
    thenHave(D === ‚àÖ) by Restate

    // Hence G1 and G2 agree on A
    have(x ‚àâ D) by Congruence.from(EmptySet.definition, lastStep)
    thenHave(x ‚àà A ==> (G1(x) === G2(x))) by Tautology.fromLastStep(`x ‚àà D`)
    thenHave(thesis) by RightForall
  }


  //////////////////////////////////////////////////////////////
  section("Existence")


  /**
    * Definition --- `g` is called an approximation of `G` if
    * 1. `dom(g) = A_<x` for some `x ‚àà A`
    * 2. For all `x ‚àà dom(g)` we have `g(x) = F(x, g ‚Üæ A_<x)`
    *
    * `g` is an approximation until `x ‚àà A` if `dom(g) = A_<x`.
    */
  private def approximation(g: Expr[Set]): Expr[Prop] =
    ‚àÉ(x, approximationUntil(g, x))
  private def approximationUntil(g: Expr[Set], x: Expr[Set]): Expr[Prop] =
    (x ‚àà A) /\ functionOn(g)(initialSegment(x)(A)(<)) /\ ‚àÄ(a ‚àà initialSegment(x)(A)(<), g(a) === F(a)(g ‚Üæ initialSegment(a)(A)(<)))


  /**
    * Lemma --- If `f` is an approximation then `f` is a function.
    */
  val approximationIsFunction = Lemma(
    approximation(f) |- function(f)
  ) {
    have(approximationUntil(f, x) |- function(f)) by Tautology.from(Functions.BasicTheorems.functionOnIsFunction of (A := initialSegment(x)(A)(<)))
    thenHave(thesis) by LeftExists
  }

  /**
    * Lemma --- The domain of an approximation is a subset of A.
    */
  val approximationDomain = Lemma(
    approximation(f) |- dom(f) ‚äÜ A
  ) {
    have((approximationUntil(f, x), x ‚àà A) |- dom(f) ‚äÜ A) by Congruence.from(
      Functions.BasicTheorems.functionOnDomain of (A := initialSegment(x)(A)(<)),
      InitialSegment.subset
    )
    thenHave(approximationUntil(f, x) |- dom(f) ‚äÜ A) by Tautology
    thenHave(thesis) by LeftExists
  }

  /**
    * Lemma --- If `f` is an approximation until `x` then `f(y) = F(y, f ‚Üæ initialSegment(y, A, <))`
    * for all `y ‚àà A_<x`.
    */
  val approximationUntilApp = Lemma(
    (approximationUntil(f, x), y ‚àà initialSegment(x)(A)(<)) |- f(y) === F(y)(f ‚Üæ initialSegment(y)(A)(<))
  ) {
    assume(approximationUntil(f, x))

    have(‚àÄ(y ‚àà initialSegment(x)(A)(<), f(y) === F(y)(f ‚Üæ initialSegment(y)(A)(<)))) by Tautology
    thenHave(thesis) by InstantiateForall(y)
  }

  /**
    * Lemma --- If `f` is an approximation then `f(x) = F(x, f ‚Üæ initialSegment(x, A, <))`
    * for all `x ‚àà dom(f)`.
    */
  val approximationApp = Lemma(
    approximation(f) |- ‚àÄ(x ‚àà dom(f), f(x) === F(x)(f ‚Üæ initialSegment(x)(A)(<)))
  ) {
    val `dom(f)` = have(approximationUntil(f, y) |- dom(f) === initialSegment(y)(A)(<)) by Tautology.from(
      Functions.BasicTheorems.functionOnDomain of (A := initialSegment(y)(A)(<))
    )

    have(approximationUntil(f, y) |- (a ‚àà initialSegment(y)(A)(<)) ==> (f(a) === F(a)(f ‚Üæ initialSegment(a)(A)(<)))) by Restate.from(approximationUntilApp of (y := a, x := y))
    thenHave(approximationUntil(f, y) |- (a ‚àà dom(f)) ==> (f(a) === F(a)(f ‚Üæ initialSegment(a)(A)(<)))) by Substitute(`dom(f)`)
    thenHave(approximationUntil(f, y) |- ‚àÄ(a ‚àà dom(f), f(a) === F(a)(f ‚Üæ initialSegment(a)(A)(<)))) by RightForall
    thenHave(‚àÉ(y, approximationUntil(f, y)) |- ‚àÄ(a ‚àà dom(f), f(a) === F(a)(f ‚Üæ initialSegment(a)(A)(<)))) by LeftExists
    thenHave(thesis) by Restate
  }


  /**
    * Lemma --- If `f` and `g` are approximations then `dom(f) ‚à© dom(g) = initialSegment(x, A, <)`
    * for some `x ‚àà A`.
    */
  val approximationDomainIntersection = Lemma(
    (wellOrder(A)(<), approximation(f), approximation(g)) |- ‚àÉ(x ‚àà A, dom(f) ‚à© dom(g) === initialSegment(x)(A)(<))
  ) {
    assume(wellOrder(A)(<))

    val `dom(f)` = have(approximationUntil(f, x) |- dom(f) === initialSegment(x)(A)(<)) by Tautology.from(
      Functions.BasicTheorems.functionOnDomain of (A := initialSegment(x)(A)(<))
    )

    have((x ‚àà A, y ‚àà A) |- ‚àÉ(z ‚àà A, (initialSegment(x)(A)(<) ‚à© initialSegment(y)(A)(<)) === initialSegment(z)(A)(<))) by Tautology.from(
      InitialSegment.intersectionIsInitialSegment
    )
    thenHave((x ‚àà A, y ‚àà A, approximationUntil(f, x), approximationUntil(g, y)) |- ‚àÉ(z ‚àà A, (dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))) by Substitute(
      `dom(f)`,
      `dom(f)` of (f := g, x := y),
    )
    thenHave((approximationUntil(f, x), approximationUntil(g, y)) |- ‚àÉ(z ‚àà A, (dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))) by Tautology
    thenHave((‚àÉ(x, approximationUntil(f, x)), approximationUntil(g, y)) |- ‚àÉ(z ‚àà A, (dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))) by LeftExists
    thenHave((‚àÉ(x, approximationUntil(f, x)), ‚àÉ(y, approximationUntil(g, y))) |- ‚àÉ(z ‚àà A, (dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))) by LeftExists
    thenHave(thesis) by Restate
  }

  /**
    * Coherence lemma --- Any two approximations of `G` agree on the
    * intersection of their domains.
    *
    * TODO: The coherence lemma could be applied to prove [[uniqueness]] by
    * relaxing the definition of approximation to include A itself. Essentially
    * the proofs of [[coherence]] and [[uniqueness]] are the same.
    */
  val coherence = Lemma(
    (wellOrder(A)(<), approximation(f), approximation(g)) |- ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))
  ) {
    assume(wellOrder(A)(<))
    assume(approximation(f))
    assume(approximation(g))

    // Unfold the definitions of f(x) and g(x) to use them later
    val `f(x)` = have(x ‚àà dom(f) |- (f(x) === F(x)(f ‚Üæ initialSegment(x)(A)(<)))) by InstantiateForall(x)(approximationApp)
    val `g(x)` = have(x ‚àà dom(g) |- (g(x) === F(x)(g ‚Üæ initialSegment(x)(A)(<)))) by InstantiateForall(x)(approximationApp of (f := g))

    // Let D = {x ‚àà dom(f) ‚à© dom(g) | f(x) ‚â† g(x)}
    val D = {x ‚àà (dom(f) ‚à© dom(g)) | f(x) ‚â† g(x)}
    val `x ‚àà D` = have(x ‚àà D <=> (x ‚àà (dom(f) ‚à© dom(g))) /\ (f(x) ‚â† g(x))) by Comprehension.apply

    // Towards a contradiction, assume that D is non-empty.
    have(D ‚â† ‚àÖ |- ‚ä•) subproof {
      assume(D ‚â† ‚àÖ)

      // Notice that D ‚äÜ A since D ‚äÜ dom(f) ‚à© dom(g) ‚äÜ dom(f) ‚äÜ A
      val `D ‚äÜ A` = have(D ‚äÜ A) subproof {
        have(D ‚äÜ dom(f)) by Tautology.from(
          Comprehension.subset of (y := dom(f) ‚à© dom(g), œÜ := Œª(x, f(x) ‚â† g(x))),
          Intersection.subsetLeft of (x := dom(f), y := dom(g)),
          Subset.transitivity of (x := D, y := dom(f) ‚à© dom(g), z := dom(f)),
        )
        thenHave(thesis) by Tautology.fromLastStep(
          approximationDomain,
          Subset.transitivity of (x := D, y := dom(f), z := A),
        )
      }

      // Hence D has a minimal element, call it x.
      // We have that f and g agree on initialSegment(x, dom(f) ‚à© dom(g), <)
      have(minimal(x)(D)(<) |- (f ‚Üæ initialSegment(x)(A)(<)) === (g ‚Üæ initialSegment(x)(A)(<))) subproof {
        assume(minimal(x)(D)(<))

        have(‚àÄ(y ‚àà D, ¬¨(y < x))) by Tautology.from(minimal.definition of (a := x, A := D))
        thenHave(y ‚àà D ==> ¬¨(y < x)) by InstantiateForall(y)
        val eq = thenHave(y ‚àà initialSegment(x)(dom(f) ‚à© dom(g))(<) ==> (f(y) === g(y))) by Tautology.fromLastStep(
          `x ‚àà D` of (x := y),
          InitialSegment.membership of (A := dom(f) ‚à© dom(g))
        )

        // Since `dom(f) ‚à© dom(g) = A_<a` for some `a ‚àà A`
        // and `x ‚àà dom(f) ‚à© dom(g)` we have that `(A_<a)_<x = A_<x`
        have((z ‚àà A, x ‚àà initialSegment(z)(A)(<)) |- initialSegment(x)(initialSegment(z)(A)(<))(<) === initialSegment(x)(A)(<)) by Tautology.from(
          InitialSegment.absorption of (x := z, y := x)
        )
        thenHave((z ‚àà A, x ‚àà (dom(f) ‚à© dom(g)), (dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<)) |- initialSegment(x)(dom(f) ‚à© dom(g))(<) === initialSegment(x)(A)(<)) by Substitute((dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))
        thenHave((x ‚àà (dom(f) ‚à© dom(g)), z ‚àà A /\ ((dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))) |- initialSegment(x)(dom(f) ‚à© dom(g))(<) === initialSegment(x)(A)(<)) by Restate
        thenHave((x ‚àà (dom(f) ‚à© dom(g)), ‚àÉ(z ‚àà A, (dom(f) ‚à© dom(g)) === initialSegment(z)(A)(<))) |- initialSegment(x)(dom(f) ‚à© dom(g))(<) === initialSegment(x)(A)(<)) by LeftExists
        thenHave(initialSegment(x)(dom(f) ‚à© dom(g))(<) === initialSegment(x)(A)(<)) by Tautology.fromLastStep(
          minimal.definition of (a := x, A := D),
          `x ‚àà D`,
          approximationDomainIntersection
        )

        have(y ‚àà initialSegment(x)(A)(<) ==> (f(y) === g(y))) by Congruence.from(lastStep, eq)
        thenHave(‚àÄ(y, y ‚àà initialSegment(x)(A)(<) ==> (f(y) === g(y)))) by RightForall
        thenHave(thesis) by Tautology.fromLastStep(
          Restriction.extensionality of (A := initialSegment(x)(A)(<), f := f, g := g),
          approximationIsFunction,
          approximationIsFunction of (f := g),
        )
      }

      // By definition of f(x) and g(x), this means that f(x) === g(x)
      have(minimal(x)(D)(<) |- f(x) === g(x)) by Congruence.from(
        lastStep,
        `f(x)`,
        `g(x)`,
      )

      // Contradiction since x ‚àà D implies f(x) ‚â† g(x)
      thenHave(minimal(x)(D)(<) |- ()) by Tautology.fromLastStep(
        minimal.definition of (a := x, A := D),
        `x ‚àà D`,
        Intersection.membership of (z := x, x := dom(f), y := dom(g))
      )
      thenHave(‚àÉ(x, minimal(x)(D)(<)) |- ()) by LeftExists
      thenHave(‚àÉ(x, minimal(x)(D)(<)) |- ()) by Tautology

      // Conclude by well-foundedness
      have(thesis) by Tautology.from(
        lastStep,
        wellOrder.definition,
        WellFoundedRelation.minimalElement of (R := <, S := D, X := A),
        `D ‚äÜ A`,
      )
    }
    // Therefore D = ‚àÖ
    thenHave(D === ‚àÖ) by Restate

    // Hence f and g agree on the intersection of their domains
    have(x ‚àâ D) by Congruence.from(lastStep, EmptySet.definition)
    thenHave(x ‚àà (dom(f) ‚à© dom(g)) ==> (f(x) === g(x))) by Tautology.fromLastStep(`x ‚àà D`)
    thenHave(thesis) by RightForall
  }

  /**
    * Lemma --- Any two approximations `f` and `g` such that `dom(f) = dom(g)` are equal.
    *
    * Consequence of the [[coherence]] lemma.
    */
  val recursionStepUniqueness = Theorem(
    (
      wellOrder(A)(<),
      approximationUntil(f, x),
      approximationUntil(g, x)
    ) |- (f === g)
  ) {
    assume(wellOrder(A)(<))
    assume(approximationUntil(f, x))

    val `f is approximation` = thenHave(approximation(f)) by RightExists
    val `dom(f)` = have(dom(f) === initialSegment(x)(A)(<)) by Tautology.from(
      Functions.BasicTheorems.functionOnDomain of (A := initialSegment(x)(A)(<))
    )

    assume(approximationUntil(g, x))
    val `g is approximation` = thenHave(approximation(g)) by RightExists
    val `dom(g)` = have(dom(g) === initialSegment(x)(A)(<)) by Tautology.from(
      Functions.BasicTheorems.functionOnDomain of (f := g, A := initialSegment(x)(A)(<))
    )

    have(‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))) by Tautology.from(
      coherence,
      `f is approximation`,
      `g is approximation`
    )
    thenHave(y ‚àà (dom(f) ‚à© dom(g)) ==> (f(y) === g(y))) by InstantiateForall(y)

    have(y ‚àà (initialSegment(x)(A)(<) ‚à© initialSegment(x)(A)(<)) ==> (f(y) === g(y))) by Congruence.from(
      lastStep,
      `dom(f)`,
      `dom(g)`
    )
    thenHave(y ‚àà initialSegment(x)(A)(<) ==> (f(y) === g(y))) by Substitute(Intersection.idempotence of (x := initialSegment(x)(A)(<)))
    thenHave(‚àÄ(y ‚àà initialSegment(x)(A)(<), f(y) === g(y))) by RightForall
    thenHave(thesis) by Tautology.fromLastStep(
      Functions.BasicTheorems.extensionality of (A := initialSegment(x)(A)(<))
    )
  }

  /**
    * We say that `p` is a predecessor of `x` if `p < x` and there does not
    * exists `y` such that `p < y < x`.
    */
  def predecessor(p: Expr[Set]): Expr[Prop] =
    (p ‚àà A) /\ (p < x) /\ ¬¨(‚àÉ(z ‚àà A, (p < z) /\ (z < x)))

  /**
    * Theorem --- If `x` has a predecessor `p` that has an approximation, then there ‚àÉ an
    * approximation until `x`.
    */
  val successorCase = Theorem(
    (
      wellOrder(A)(<),
      x ‚àà A,
      predecessor(p),
      ‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y)))
    ) |-
      ‚àÉ(G, approximationUntil(G, x))
  ) {
    assume(wellOrder(A)(<))
    assume(x ‚àà A)

    assume(‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y))))
    thenHave((y ‚àà A) ==> ((y < x) ==> ‚àÉ!(G, approximationUntil(G, y)))) by InstantiateForall(y)
    thenHave((y ‚àà A, y < x) |- ‚àÉ!(G, approximationUntil(G, y))) by Restate
    val `approximationUntil(G_y, y)` = thenHave((y ‚àà A, y < x) |- approximationUntil(Œµ(G, approximationUntil(G, y)), y)) by Tautology.fromLastStep(
      Quantifiers.existsOneEpsilon of (P := Œª(G, approximationUntil(G, y)))
    )

    assume(predecessor(p))

    /** We show that `G_x = G_p ‚à™ {(p, F(p, G_p))}` is the desired approximation.
      * This follows from the fact that `A_<x = A_<p ‚à™ {p}` and thus `G_x` is a
      * point extension of `G_p`.
      */
    val G_p = Œµ(G, approximationUntil(G, p))
    val G_x = G_p ‚à™ singleton((p, F(p)(G_p)))

    val initialSegmentPartition = have(initialSegment(x)(A)(<) === initialSegment(p)(A)(<) ‚à™ singleton(p)) by Tautology.from(InitialSegment.successor)

    val `y ‚àà initialSegment(x)(A)(<)` = have(y ‚àà initialSegment(x)(A)(<) <=> (y ‚àà initialSegment(p)(A)(<)) \/ (y === p)) by Congruence.from(
      initialSegmentPartition,
      Union.membership of (z := y, x := initialSegment(p)(A)(<), y := singleton(p)),
      Singleton.membership of (x := p)
    )

    /** 1. `G_x` is a function on `A_<x` */
    val `function(G_p)` = have(function(G_p)) by Tautology.from(
      `approximationUntil(G_y, y)` of (y := p),
      Functions.BasicTheorems.functionOnIsFunction of (f := G_p, A := initialSegment(p)(A)(<))
    )

    val `dom(G_p)` = have(dom(G_p) === initialSegment(p)(A)(<)) by Tautology.from(
      `approximationUntil(G_y, y)` of (y := p),
      Functions.BasicTheorems.functionOnDomain of (f := G_p, A := initialSegment(p)(A)(<))
    )

    val `G_p(y)` = have(y ‚àà initialSegment(p)(A)(<) |- G_p(y) === F(y)(G_p ‚Üæ initialSegment(y)(A)(<))) by Tautology.from(
      `approximationUntil(G_y, y)` of (y := p),
      approximationUntilApp of (f := G_p, x := p)
    )

    val `p ‚àâ dom(G_p)` =
      have(p ‚àâ initialSegment(p)(A)(<)) by Tautology.from(
        membership of (y := p, x := p),
        WellOrder.irreflexivity,
        Relations.BasicTheorems.appliedIrreflexivity of (R := <, X := A, x := p)
      )
      thenHave(p ‚àâ dom(G_p)) by Substitute(`dom(G_p)`)

    val `G_x is a function on A_<x` =
      have(functionOn(G_x)(dom(G_p) ‚à™ singleton(p))) by Tautology.from(
        Functions.BasicTheorems.pointExtension of (f := G_p, x := p, y := F(p)(G_p)),
        `function(G_p)`,
        `p ‚àâ dom(G_p)`
      )
      thenHave(functionOn(G_x)(initialSegment(p)(A)(<) ‚à™ singleton(p))) by Substitute(`dom(G_p)`)
      thenHave(functionOn(G_x)(initialSegment(x)(A)(<))) by Substitute(initialSegmentPartition)

    val `G_x is a function` = have(function(G_x)) by Tautology.from(
      `G_x is a function on A_<x`,
      Functions.BasicTheorems.functionOnIsFunction of (f := G_x, A := initialSegment(x)(A)(<))
    )

    val `dom(G_x)` = have(dom(G_x) === initialSegment(x)(A)(<)) by Tautology.from(
      `G_x is a function on A_<x`,
      Functions.BasicTheorems.functionOnDomain of (f := G_x, A := initialSegment(x)(A)(<))
    )

    val `p ‚àà dom(G_x)` =
      have(p ‚àà initialSegment(x)(A)(<)) by Tautology.from(InitialSegment.membership of (y := p))
      thenHave(p ‚àà dom(G_x)) by Substitute(`dom(G_x)`)

    val `G_p = G_x ‚Üæ A_<p` =
      have(G_p === (G_x ‚Üæ dom(G_p))) by Tautology.from(
        Restriction.subsetIsRestriction of (g := G_p, f := G_x),
        Union.leftSubset of (x := G_p, y := singleton((p, F(p)(G_p)))),
        `G_x is a function`
      )
      thenHave(G_p === (G_x ‚Üæ initialSegment(p)(A)(<))) by Substitute(`dom(G_p)`)

    /** 2. For all `a ‚àà A_<x` we have `G_x(a) = F(a, G_x ‚Üæ a)`.
      * Essentially, we have to show 2 things:
      * a. For `a = p` we have `G_x(p) = F(p, G_p)` by construction, i.e. `G_x ‚Üæ A_<p = G_p`.
      * b. For `a ‚àà A_<p` we have `G_x ‚Üæ A_<a = G_p ‚Üæ A_<a`.
      */
    val `G_x(p)` = {
      have(G_x(p) === F(p)(G_x ‚Üæ initialSegment(p)(A)(<))) subproof {
        have((p, F(p)(G_p)) ‚àà G_x) by Tautology.from(
          Union.membership of (z := (p, F(p)(G_p)), x := G_p, y := singleton((p, F(p)(G_p)))),
          Singleton.membership of (y := (p, F(p)(G_p)), x := (p, F(p)(G_p)))
        )
        thenHave(G_x(p) === F(p)(G_p)) by Tautology.fromLastStep(
          Functions.BasicTheorems.appDefinition of (f := G_x, x := p, y := F(p)(G_p)),
          `G_x is a function`,
          `p ‚àà dom(G_x)`,
        )

        // Conclude
        have(thesis) by Congruence.from(lastStep, `G_p = G_x ‚Üæ A_<p`)
      }
      thenHave(y === p |- G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<))) by Congruence
    }

    val `G_x(y)` = have(y ‚àà initialSegment(p)(A)(<) |- G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<))) subproof {
      assume(y ‚àà initialSegment(p)(A)(<))

      have(y ‚àà initialSegment(x)(A)(<)) by Tautology.from(`y ‚àà initialSegment(x)(A)(<)`)
      thenHave(y ‚àà dom(G_x)) by Substitute(`dom(G_x)`)
      thenHave((G_x ‚Üæ initialSegment(p)(A)(<))(y) === G_x(y)) by Tautology.fromLastStep(
        Restriction.restrictedApp of (f := G_x, A := initialSegment(p)(A)(<), x := y),
        `G_x is a function`
      )
      thenHave(G_p(y) === G_x(y)) by Substitute(`G_p = G_x ‚Üæ A_<p`)
      thenHave(F(y)(G_p ‚Üæ initialSegment(y)(A)(<)) === G_x(y)) by Substitute(`G_p(y)`)
      thenHave(F(y)((G_x ‚Üæ initialSegment(p)(A)(<)) ‚Üæ initialSegment(y)(A)(<)) === G_x(y)) by Substitute(`G_p = G_x ‚Üæ A_<p`)

      // It remains to remove the redundant restriction
      thenHave(F(y)(G_x ‚Üæ (initialSegment(p)(A)(<) ‚à© initialSegment(y)(A)(<))) === G_x(y)) by Substitute(Restriction.doubleRestriction of (f := G_x, A := initialSegment(p)(A)(<), B := initialSegment(y)(A)(<)))
      thenHave(F(y)(G_x ‚Üæ (initialSegment(y)(A)(<) ‚à© initialSegment(p)(A)(<))) === G_x(y)) by Substitute(
        Intersection.commutativity of (x := initialSegment(p)(A)(<), y := initialSegment(y)(A)(<))
      )
      thenHave((y < p, y ‚àà A) |- F(y)(G_x ‚Üæ initialSegment(y)(A)(<)) === G_x(y)) by Substitute(
        InitialSegment.intersection of (x := y, y := p),
      )

      thenHave(thesis) by Tautology.fromLastStep(InitialSegment.membership of (x := p))
    }

    have(y ‚àà initialSegment(x)(A)(<) ==> (G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by Tautology.from(
      `G_x(p)`,
      `G_x(y)`,
      `y ‚àà initialSegment(x)(A)(<)`
    )
    thenHave(‚àÄ(y ‚àà initialSegment(x)(A)(<), G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by RightForall

    /** Conclude. */
    have(approximationUntil(G_x, x)) by Tautology.from(
      lastStep,
      `G_x is a function on A_<x`,
    )
    thenHave(thesis) by RightExists
  }

  /**
    * Theorem --- If `x` is limit, then there ‚àÉ an approximation until `x`.
    */
  val limitCase = Theorem(
    (
      wellOrder(A)(<),
      x ‚àà A,
      ‚àÄ(p, ¬¨(predecessor(p))),
      ‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y)))
    ) |-
      ‚àÉ(G, approximationUntil(G, x))
  ) {
    assume(wellOrder(A)(<))
    assume(x ‚àà A)
    assume(‚àÄ(p, ¬¨(predecessor(p))))
    val `¬¨predecessor(y)` = thenHave(¬¨(predecessor(y))) by InstantiateForall(y)

    /** Let `G_y` be the approximation until `y`. */
    def G_(y: Expr[Set]): Expr[Set] = Œµ(G, approximationUntil(G, y))

    assume(‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y))))
    thenHave((y ‚àà A) ==> ((y < x) ==> ‚àÉ!(G, approximationUntil(G, y)))) by InstantiateForall(y)
    thenHave(y ‚àà initialSegment(x)(A)(<) |- ‚àÉ!(G, approximationUntil(G, y))) by Tautology.fromLastStep(InitialSegment.membership)
    val `approximationUntil(G_y, y)` = thenHave(y ‚àà initialSegment(x)(A)(<) |- approximationUntil(G_(y), y)) by Tautology.fromLastStep(
      Quantifiers.existsOneEpsilon of (P := Œª(G, approximationUntil(G, y)))
    )
    val `approximation(G_y)` = thenHave(y ‚àà initialSegment(x)(A)(<) |- approximation(G_(y))) by RightExists

    /**
      * If `x` is limit, for `G_x = ‚ãÉ{G_y | y < x}` we have that:
      * 1. `G_x` is a function since all of the approximations are coherent
      * 2. `dom(G_x) = ‚ãÉ{dom(G_y) | y < x} = A_<x`
      * 3. For any `y < x` we have `G_x ‚Üæ A_<y = G_y`.
      */
    val S = { G_(y) | y ‚àà initialSegment(x)(A)(<) }
    val G_x = ‚ãÉ(S)

    val replacement_F = Variable[Set >>: Set]("F") // Unfortunate name clash with F : Set -> Set -> Set
    val `G_y ‚àà S` = have(y ‚àà initialSegment(x)(A)(<) |- G_(y) ‚àà S) by Tautology.from(
      Replacement.map of (A := initialSegment(x)(A)(<), x := y, replacement_F := Œª(y, G_(y)))
    )

    val `G_y ‚äÜ G_x` = have(y ‚àà initialSegment(x)(A)(<) |- G_(y) ‚äÜ G_x) by Tautology.from(
      `G_y ‚àà S`,
      Union.subset of (y := G_(y), x := S)
    )

    /** 1. `G_x` is a function */
    val `f ‚àà S` = have(f ‚àà S <=> ‚àÉ(y ‚àà initialSegment(x)(A)(<), G_(y) === f)) by Replacement.apply

    val `G_y is a function` = have(y ‚àà initialSegment(x)(A)(<) |- function(G_(y))) by Tautology.from(
      `approximationUntil(G_y, y)`,
      Functions.BasicTheorems.functionOnIsFunction of (f := G_(y), A := initialSegment(y)(A)(<))
    )

    val `dom(G_y)` = have(y ‚àà initialSegment(x)(A)(<) |- dom(G_(y)) === initialSegment(y)(A)(<)) by Tautology.from(
      `approximationUntil(G_y, y)`,
      Functions.BasicTheorems.functionOnDomain of (f := G_(y), A := initialSegment(y)(A)(<))
    )

    val `f ‚àà S is a function` = {
      have((y ‚àà initialSegment(x)(A)(<), f === G_(y)) |- function(f)) by Congruence.from(`G_y is a function`)
      thenHave((y ‚àà initialSegment(x)(A)(<)) /\ (f === G_(y)) |- function(f)) by Restate
      thenHave(‚àÉ(y ‚àà initialSegment(x)(A)(<), f === G_(y)) |- function(f)) by LeftExists
      thenHave(f ‚àà S |- function(f)) by Substitute(`f ‚àà S`)
      thenHave(f ‚àà S ==> function(f)) by Restate
      thenHave(‚àÄ(f, f ‚àà S ==> function(f))) by RightForall
    }

    val `f, g ‚àà S are coherent` = {
      have((y ‚àà initialSegment(x)(A)(<), z ‚àà initialSegment(x)(A)(<)) |- approximation(G_(y)) /\ approximation(G_(z))) by Tautology.from(
        `approximation(G_y)`,
        `approximation(G_y)` of (y := z),
      )
      thenHave(
        (
          y ‚àà initialSegment(x)(A)(<), f === G_(y),
          z ‚àà initialSegment(x)(A)(<), g === G_(z)
        ) |- approximation(f) /\ approximation(g)
      ) by Substitute(f === G_(y), g === G_(z))
      thenHave(
        (
          (y ‚àà initialSegment(x)(A)(<)) /\ (f === G_(y)),
          (z ‚àà initialSegment(x)(A)(<)) /\ (g === G_(z))
        ) |- ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))
      ) by Tautology.fromLastStep(coherence)
      thenHave(
        (
          ‚àÉ(y ‚àà initialSegment(x)(A)(<), f === G_(y)),
          (z ‚àà initialSegment(x)(A)(<)) /\ (g === G_(z))
        ) |- ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))
      ) by LeftExists
      thenHave(
        (
          ‚àÉ(y ‚àà initialSegment(x)(A)(<), f === G_(y)),
          ‚àÉ(z ‚àà initialSegment(x)(A)(<), g === G_(z))
        ) |- ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))
      ) by LeftExists
      thenHave((f ‚àà S, g ‚àà S) |- ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))) by Substitute(
        `f ‚àà S`, `f ‚àà S` of (f := g)
      )
      thenHave(f ‚àà S |- (g ‚àà S) ==> ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))) by Restate
      thenHave(f ‚àà S |- ‚àÄ(g ‚àà S, ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x)))) by RightForall
      thenHave(f ‚àà S ==> ‚àÄ(g ‚àà S, ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x)))) by Restate
      thenHave(‚àÄ(f ‚àà S, ‚àÄ(g ‚àà S, ‚àÄ(x ‚àà (dom(f) ‚à© dom(g)), f(x) === g(x))))) by RightForall
    }

    val `G_x is a function` = have(function(G_x)) by Tautology.from(
      Functions.Operations.Union.isFunction of (ùìï := S),
      `f ‚àà S is a function`,
      `f, g ‚àà S are coherent`
    )

    /** 2. `dom(G_x) = A_<x` */
    val `dom(G_x)` = have(dom(G_x) === initialSegment(x)(A)(<)) subproof {
      /** We proceed by double inclusion: we have both
        * 1. dom(G_x) ‚äÜ A_<x, for dom(G_y) ‚äÜ A_<x for every y ‚àà A_<x
        * 2. A_<x ‚äÜ dom(G_x), since for every y ‚àà A_<x there ‚àÉ z > y such that y ‚àà dom(G_z)
        */

      val D = { dom(f) | f ‚àà S }
      val `d ‚àà D` = have(d ‚àà D <=> ‚àÉ(f ‚àà S, dom(f) === d)) by Replacement.apply

      val `dom(G_y) ‚àà D` =
        have(y ‚àà initialSegment(x)(A)(<) |- (G_(y) ‚àà S) /\ (dom(G_(y)) === dom(G_(y)))) by Tautology.from(`G_y ‚àà S`)
        thenHave(y ‚àà initialSegment(x)(A)(<) |- ‚àÉ(f ‚àà S, dom(f) === dom(G_(y)))) by RightExists
        thenHave(y ‚àà initialSegment(x)(A)(<) |- dom(G_(y)) ‚àà D) by Substitute(`d ‚àà D` of (d := dom(G_(y))))

      val `==>` = have(‚ãÉ(D) ‚äÜ initialSegment(x)(A)(<)) subproof {
        have((y ‚àà A, y < x, G_(y) === f, dom(f) === d) |- d ‚äÜ initialSegment(x)(A)(<)) by Congruence.from(
          InitialSegment.monotonic of (x := y, y := x),
          `dom(G_y)`,
        )
        thenHave(((y ‚àà initialSegment(x)(A)(<)) /\ (G_(y) === f), dom(f) === d) |- d ‚äÜ initialSegment(x)(A)(<)) by Tautology.fromLastStep(
          InitialSegment.membership,
        )
        thenHave((‚àÉ(y ‚àà initialSegment(x)(A)(<), G_(y) === f), dom(f) === d) |- d ‚äÜ initialSegment(x)(A)(<)) by LeftExists
        thenHave((f ‚àà S, dom(f) === d) |- d ‚äÜ initialSegment(x)(A)(<)) by Substitute(`f ‚àà S`)
        thenHave((f ‚àà S) /\ (dom(f) === d) |- d ‚äÜ initialSegment(x)(A)(<)) by Restate
        thenHave(‚àÉ(f ‚àà S, dom(f) === d) |- d ‚äÜ initialSegment(x)(A)(<)) by LeftExists
        thenHave(d ‚àà D |- d ‚äÜ initialSegment(x)(A)(<)) by Substitute(`d ‚àà D`)
        thenHave(d ‚àà D ==> (d ‚äÜ initialSegment(x)(A)(<))) by Restate
        thenHave(‚àÄ(d ‚àà D, d ‚äÜ initialSegment(x)(A)(<))) by RightForall
        thenHave(thesis) by Tautology.fromLastStep(Union.leftUnaryUnionSubset of (z := initialSegment(x)(A)(<), x := D))
      }

      val `<==` = have(initialSegment(x)(A)(<) ‚äÜ ‚ãÉ(D)) subproof {
        /** Since `y` is limit, `y ‚àà dom(G_z)` for any `z > y`. */
        have((y ‚àà initialSegment(x)(A)(<), z ‚àà initialSegment(x)(A)(<), y < z) |- y ‚àà initialSegment(z)(A)(<)) by Tautology.from(
          InitialSegment.membership,
          InitialSegment.membership of (x := z),
          InitialSegment.membership of (y := z),
        )
        thenHave((y ‚àà initialSegment(x)(A)(<), z ‚àà initialSegment(x)(A)(<), y < z) |- y ‚àà dom(G_(z))) by Substitute(`dom(G_y)` of (y := z))
        thenHave((y ‚àà initialSegment(x)(A)(<), z ‚àà initialSegment(x)(A)(<), y < z) |- (dom(G_(z)) ‚àà D) /\ y ‚àà dom(G_(z))) by Tautology.fromLastStep(`dom(G_y) ‚àà D` of (y := z))
        thenHave((y ‚àà initialSegment(x)(A)(<), z ‚àà initialSegment(x)(A)(<), y < z) |- ‚àÉ(d ‚àà D, y ‚àà d)) by RightExists
        thenHave((y ‚àà initialSegment(x)(A)(<), z ‚àà initialSegment(x)(A)(<), y < z) |- y ‚àà ‚ãÉ(D)) by Substitute(‚ãÉ.definition of (z := y, x := D))
        thenHave((z ‚àà A) /\ (y < z) /\ (z < x) |- y ‚àà initialSegment(x)(A)(<) ==> (y ‚àà ‚ãÉ(D))) by Tautology.fromLastStep(
          InitialSegment.membership of (y := z),
        )
        thenHave(‚àÉ(z ‚àà A, (y < z) /\ (z < x)) |- y ‚àà initialSegment(x)(A)(<) ==> (y ‚àà ‚ãÉ(D))) by LeftExists
        thenHave(y ‚àà initialSegment(x)(A)(<) ==> (y ‚àà ‚ãÉ(D))) by Tautology.fromLastStep(
          `¬¨predecessor(y)`,
          InitialSegment.membership
        )
        thenHave(‚àÄ(y, y ‚àà initialSegment(x)(A)(<) ==> (y ‚àà ‚ãÉ(D)))) by RightForall
        thenHave(thesis) by Substitute(‚äÜ.definition of (x := initialSegment(x)(A)(<), y := ‚ãÉ(D)))
      }

      have(‚ãÉ(D) === initialSegment(x)(A)(<)) by Tautology.from(
        `==>`,
        `<==`,
        Subset.doubleInclusion of (x := ‚ãÉ(D), y := initialSegment(x)(A)(<))
      )
      thenHave(thesis) by Substitute(Functions.Operations.Union.domain of (ùìï := S))
    }

    /** 3. For all `y < x` we have `G_x(y) = F(y, G_x ‚Üæ A_<y)`.
      *
      * Since `x` is limit, there exists an element `y < z < x` such that
      * `G_x(y) = G_z(y)`, and by construction
      *
      *   `G_z(y) = F(y, G_z ‚Üæ A_<y) = F(y, G_x ‚Üæ A_<y)`
      *
      * as desired.
      */
    val `G_y = G_x ‚Üæ A_<y` =
      have(y ‚àà initialSegment(x)(A)(<) |- G_(y) === (G_x ‚Üæ dom(G_(y)))) by Tautology.from(
        Restriction.subsetIsRestriction of (f := G_x, g := G_(y)),
        `G_x is a function`,
        `G_y ‚äÜ G_x`
      )
      thenHave(y ‚àà initialSegment(x)(A)(<) |- G_(y) === (G_x ‚Üæ initialSegment(y)(A)(<))) by Substitute(`dom(G_y)`)

    have(y ‚àà initialSegment(x)(A)(<) |- G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<))) subproof {
      assume(y ‚àà initialSegment(x)(A)(<))

      val `y ‚àà dom(G_z)` = have(y ‚àà initialSegment(z)(A)(<) |- y ‚àà dom(G_(z))) by Congruence.from(`dom(G_y)` of (y := z))

      /** We show that if `y < z` then `G_z(y) = F(y, G_x ‚Üæ A_<y)`. */
      have((y ‚àà initialSegment(z)(A)(<), z ‚àà initialSegment(x)(A)(<)) |- G_(z)(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<))) subproof {
        assume(y ‚àà initialSegment(z)(A)(<))
        assume(z ‚àà initialSegment(x)(A)(<))

        have(G_(z)(y) === F(y)(G_(z) ‚Üæ initialSegment(y)(A)(<))) by Tautology.from(
          approximationUntilApp of (f := G_(z), x := z),
          `approximationUntil(G_y, y)` of (y := z)
        )
        thenHave(G_(z)(y) === F(y)((G_x ‚Üæ initialSegment(z)(A)(<)) ‚Üæ initialSegment(y)(A)(<))) by Substitute(
          `G_y = G_x ‚Üæ A_<y` of (y := z)
        )
        thenHave(G_(z)(y) === F(y)(G_x ‚Üæ (initialSegment(z)(A)(<) ‚à© initialSegment(y)(A)(<)))) by Substitute(
          Restriction.doubleRestriction of (f := G_x, A := initialSegment(z)(A)(<), B := initialSegment(y)(A)(<))
        )
        thenHave(G_(z)(y) === F(y)(G_x ‚Üæ (initialSegment(y)(A)(<) ‚à© initialSegment(z)(A)(<)))) by Substitute(
          Intersection.commutativity of (x := initialSegment(y)(A)(<), y := initialSegment(z)(A)(<))
        )
        thenHave((y < z, y ‚àà A, z ‚àà A) |- G_(z)(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<))) by Substitute(
          InitialSegment.intersection of (x := y, y := z)
        )
        thenHave(thesis) by Tautology.fromLastStep(
          InitialSegment.membership of (x := z),
          InitialSegment.membership of (y := z),
        )
      }

      /** Since `G_z ‚äÜ G_x` we have `G_x(y) = G_z(y) = F(y, G_x ‚Üæ A_<y)` as desired. */
      have((y ‚àà initialSegment(z)(A)(<), z ‚àà initialSegment(x)(A)(<)) |- (G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by Tautology.from(
        lastStep,
        Functions.BasicTheorems.extensionApp of (f := G_x, g := G_(z), x := y, y := F(y)(G_x ‚Üæ initialSegment(y)(A)(<))),
        `G_x is a function`,
        `G_y is a function` of (y := z),
        `G_y ‚äÜ G_x` of (y := z),
        `y ‚àà dom(G_z)`
      )

      /** Infer the existence of `z` since `x` is limit. */
      thenHave((y ‚àà A, (z ‚àà A) /\ (y < z) /\ (z < x)) |- (G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by Tautology.fromLastStep(
        InitialSegment.membership of (x := z),
        InitialSegment.membership of (y := z),
      )
      thenHave((y ‚àà A, ‚àÉ(z ‚àà A, (y < z) /\ (z < x))) |- (G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by LeftExists
      thenHave(thesis) by Tautology.fromLastStep(
        `¬¨predecessor(y)`,
        InitialSegment.membership,
      )
    }
    thenHave(y ‚àà initialSegment(x)(A)(<) ==> (G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by Restate
    thenHave(‚àÄ(y ‚àà initialSegment(x)(A)(<), G_x(y) === F(y)(G_x ‚Üæ initialSegment(y)(A)(<)))) by RightForall

    have(approximationUntil(G_x, x)) by Tautology.from(
      lastStep,
      Functions.BasicTheorems.functionOnIffFunctionWithDomain of (f := G_x, A := initialSegment(x)(A)(<)),
      `G_x is a function`,
      `dom(G_x)`
    )
    thenHave(thesis) by RightExists
  }

  /**
    * Theorem --- Assuming that there ‚àÉ a unique approximation `G_y` for all `y < x`, construct
    * an approximation `G_x` with `dom(G_x) = initialSegment(x, A, <)`.
    */
  val recursionStepExistence = Theorem(
    (
      wellOrder(A)(<),
      x ‚àà A,
      ‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y)))
    ) |-
      ‚àÉ(G, approximationUntil(G, x))
  ) {
    assume(wellOrder(A)(<))
    assume(x ‚àà A)
    assume(‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y))))

    val `x has a predecessor` = have(‚àÉ(p, predecessor(p)) |- ‚àÉ(G, approximationUntil(G, x))) by LeftExists(successorCase)
    val `x is limit` = limitCase

    have(thesis) by Tautology.from(`x has a predecessor`, `x is limit`)
  }

  /**
    * Theorem --- Assuming that there ‚àÉ a unique approximation `G_y` for all `y < x`, there ‚àÉ
    * a unique approximation `G_x` with `dom(G_x) = initialSegment(x, A, <)`.
    *
    * Combines [[recursionStepExistence]] with [[recursionStepUniqueness]].
    */
  val recursionStep = Theorem(
    (
      wellOrder(A)(<),
      x ‚àà A,
      ‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y)))
    ) |-
      ‚àÉ!(G, approximationUntil(G, x))
  ) {
    assume(wellOrder(A)(<))
    assume(x ‚àà A)
    assume(‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y))))

    val existence = have(‚àÉ(G, approximationUntil(G, x))) by Tautology.from(recursionStepExistence)

    val uniqueness =
      have(approximationUntil(f, x) /\ approximationUntil(g, x) ==> (f === g)) by Tautology.from(recursionStepUniqueness)
      thenHave(‚àÄ(f, ‚àÄ(g, approximationUntil(f, x) /\ approximationUntil(g, x) ==> (f === g)))) by Generalize

    have(thesis) by Tautology.from(
      existence, uniqueness,
      Quantifiers.existsOneAlternativeDefinition of (P := Œª(f, approximationUntil(f, x)))
    )
  }

  /**
    * Theorem --- For any `x ‚àà A` there ‚àÉ an approximation on `A_<x`.
    *
    * This theorem justifies the construction of sequences of ordinals up to an
    * ordinal `Œ±`, since `(Œ±, ‚àà_Œ±)` is a well-order.
    */
  val recursiveSequence = Theorem(
    wellOrder(A)(<) |- ‚àÄ(x ‚àà A, ‚àÉ!(G, approximationUntil(G, x)))
  ) {
    assume(wellOrder(A)(<))

    // Apply [[WellOrderedInduction.induction]] on [[recursionStep]].
    have(x ‚àà A ==> (‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y))) ==> ‚àÉ!(G, approximationUntil(G, x)))) by Restate.from(recursionStep)
    thenHave(‚àÄ(x ‚àà A, ‚àÄ(y ‚àà A, (y < x) ==> ‚àÉ!(G, approximationUntil(G, y))) ==> ‚àÉ!(G, approximationUntil(G, x)))) by RightForall
    thenHave(thesis) by Tautology.fromLastStep(
      WellOrderedInduction.induction of (P := Œª(x, ‚àÉ!(G, approximationUntil(G, x))))
    )
  }

  /**
   * Well-ordered recursion --- Given `F : V √ó V -> V` and a well-order `(A, <)`
   * there exists a function `G : A -> V` such that
   *
   *   `‚àÄx ‚àà A. G(x) = F(x, G‚ÜæA_<x)`
   *
   * This recursion principle implies recursion on any ordinal `Œ±`, since `Œ±`
   * is well-ordered by the membership relation, and `Œ±_<Œ≤ = Œ≤` for `Œ≤ ‚àà Œ±`.
    */
  val existence = Theorem(
    wellOrder(A)(<) |- ‚àÉ(G, ‚àÄ(x ‚àà A, G(x) === F(x)(G ‚Üæ initialSegment(x)(A)(<))))
  ) {
    assume(wellOrder(A)(<))

    /** We use [[recursiveSequence]] on the successor well-order `(A ‚à™ {m}, < ‚à™
      * {(x, m) | x ‚àà A})` where `m` is a fresh element. Hence we obtain a
      * function that is defined for all `x < m`, i.e. for all `x ‚àà A`.
      *
      * This also means that this theorem isn't necessary per se (and
      * [[recursiveSequence]] is enough), since this successor trick always
      * works.
      */

    sorry
  }

  /**
    * Definition --- `recursiveFunction(F, A, <)` builds the function obtained by well-ordered
    * recursion of `F` on `(A, <)`.
    */
  val recursiveFunction = DEF(Œª(F, Œª(A, Œª(<, Œµ(G, ‚àÄ(x ‚àà A, G(x) === F(x)(G ‚Üæ initialSegment(x)(A)(<))))))))

}
