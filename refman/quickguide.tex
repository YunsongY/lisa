\chapter{Starting with Proofs in Lisa}
\label{chapt:quickguide}
Lisa is a proof assistant mechanizing first-order logic. It facilitates the
development of formal proofs of mathematical statements and their verification.

The centerpiece of Lisa, called the \emph{kernel}, contains an implementation of
first-order logic (FOL) formulas and proofs. This kernel is what provides
correctness guarantees to the user. The kernel only accepts a small set of
formal deduction rule such as ``if $a$ is true and $b$ is true then $a\land b$
is true''. This is in contrast to human-written proofs, which may contain a wide
variety of complex or implicit arguments. If a proof is accepted as being
correct by the kernel, it is expected to meet objective criteria for valid
proofs according to the field of formal mathematical logic.
%
% \footnote{It is
% possible that the kernel itself has an implementation bug, but because it is a
% very small and simple program available in open source, we can build strong
% confidence that it is correct.}
%
Lisa's kernel is described in more detail in
\Cref{chapt:kernel}.

Writing mathematical theories (for example, group theory, combinatorics,
topology, theory of computation) directly from these primitive constructions
would be tedious. Instead, we use them as building blocks that can be combined
and automated. Beyond the correctness guarantees of the kernel, Lisa's purpose
is to provide tools to make writing formal proofs easier. This includes
automation, via search procedures that automatically prove theorems, and layers
of abstraction (helpers, domain specific language), which make the presentation
of formal statements and proofs closer to the traditional, human way of writing
proofs, all while within the context of the Scala programming language.

This ideology is similar to programming languages: machine language is
sufficient to write any program on a computer, but high-level programming
languages offer many convenient features which make writing complex programs
easier, and are ultimately translated into assembly automatically.
\Cref{chapt:prooflib} explains how these layers of abstraction and automation
work. The rest of the present chapter gives a quick guide on how to install and
start using Lisa.

\section{Installation}

Lisa requires the Scala programming language to run. You can download and
install Scala and sbt following the instructions at the Scala home
page\footnote{\url{www.scala-lang.org/}}. Subsequently, clone the Lisa git
repository:
%
\begin{lstlisting}[language=console]
> git clone https://github.com/epfl-lara/lisa
\end{lstlisting}
%
To test your installation, move into the directory and run the \lstinline|sbt|
build tool:
%
\begin{lstlisting}[language=console]
> cd lisa
> sbt
\end{lstlisting}
%
Once inside the sbt interactive console, use the following commands to run the
bundled examples:
%
\begin{lstlisting}[language=console]
> project lisa-examples
> runMain Example
\end{lstlisting}
Wait for the Lisa codebase to be compiled and then press the number
corresponding to "Example". You should obtain the result demonstrating some
example theorems proven, such as the following:

\noindent
\begin{minipage}{\linewidth}\vspace{1em}
\begin{lstlisting}[language=console]
Theorem fixedPointDoubleApplication :=
    ∀(x, P(x) ⇒ P(f(x))) ⊢ P(x) ⇒ P(f(f(x)))
Theorem union :=
    ⊢ x ⊆ x
Theorem leftEmpty :=
    ⊢ ∅ ⊆ x
Theorem setWithElementNonEmpty :=
    y ∈ x ⊢ ¬(x = ∅)
\end{lstlisting}
\end{minipage}

You may need a unicode font and compatible terminal if symbols are not displayed
correctly.

\section{Development Environment}
To write Lisa proofs, you can use any text editor or IDE. We recommend using \emph{Visual Studio Code} (henceforth VSCode) with the \emph{Metals} plugin.

\subsection*{A Note on Special Characters}
Mathematical development often uses symbols beyond the Latin alphabet. Lisa
usually admits both an English alphabet name and a unicode name for such
symbols. By enabling \emph{font ligatures}, common character sequences, such as
\lstinline|=|\lstinline|=|\lstinline|>| are rendered as \lstinline|==>|. The
present document also uses the font
\href{https://github.com/tonsky/FiraCode}{Fira Code}. Once installed on your
system, you can activate it and ligatures on VSCode the following way:
%
\begin{enumerate}
  \item Press Ctrl-Shift-P
  \item Search for ``Open User Settings (JSON)''
  \item in the \lstinline|settings.json| file, add (you may wish to preserve your choice of fallback fonts in the list):
    %
  \begin{lstlisting}
"editor.fontFamily": "'Fira Code', Consolas, monospace",
"editor.fontLigatures": true,
  \end{lstlisting}
    %
\end{enumerate}

Other symbols such as \lstinline|∀| are Unicode symbols, which can be entered
via their unicode code, depending on your OS\footnote{alt+numpad on windows,
Ctrl-Shift-U+code on Linux}, or by using an extension for VS Code such as
\emph{Fast Unicode Math Characters}, \emph{Insert Unicode}, or \emph{Unicode
Latex}. A cheat sheet of the most common symbols and how to input them is in
\Cref{tab:Unicode}.
%
\begin{table}
  \center
  \begin{tabular}{c|c|c|c}
    Rendering         & Input            & Latex input & Name     \\ \hline
    \lstinline| === | & ===              & & equality \\ \hline
    \lstinline| \/  | & \textbackslash / & & or       \\ \hline
    \lstinline| /\  | & /\textbackslash  & & and      \\ \hline
    \lstinline| ==> | & ==>              & & implies  \\ \hline
    \lstinline+ |-  + &  |-              & & vdash    \\ \hline
    \lstinline| ∀   | & U+2200           & \(\backslash\)forall & forall   \\ \hline
    \lstinline| ∃   | & U+2203           & \(\backslash\)exists & exists   \\ \hline
    \lstinline| ∈   | & U+2208           & \(\backslash\)in & in       \\ \hline
    \lstinline| ⊆   | & U+2286           & \(\backslash\)subseteq & subseteq \\ \hline
    \lstinline| ∅   | & U+2205           & \(\backslash\)emptyset & emptyset \\
  \end{tabular}
  \caption{Frequently used Unicode symbols, Latex input snippets, and representation with ligatures.}
  \label{tab:Unicode}
\end{table}
Note that by default, Unicode characters may not be printed correctly on a
Windows console. You will need to activate the corresponding charset and pick a
font with support for Unicode in your console's options, such as Consolas.

\section{Writing theory files}
Lisa provides a canonical way of writing and organizing kernel proofs by means
of a set of utilities and a domain-specific language (DSL) made possible by some
of Scala's features. To prove some theorems by yourself, start by creating a
file named \lstinline|MyTheory.scala| right next to the
\lstinline|Example.scala| file \footnote{The relative path for this directory is
lisa/lisa-examples/src/main/scala}.

\needspace{4\baselineskip}
In the newly created file, write:

\noindent
\begin{minipage}{\linewidth}\vspace{0.5em}
\begin{lstlisting}[language=lisa, frame=single]
object MyTheory extends lisa.Main {

}
\end{lstlisting}
\end{minipage}
%
and that's it! This will give you access to all the Lisa features necessary to
start working. Let's see how one can use them to prove a theorem:
$$
\forall x. P(x) \implies P(f(x)) \vdash P(x) \implies P(f(f(x)))
$$
To state the theorem, we first need to tell Lisa that $x$ is a variable, $f$ is a function symbol and $P$ a predicate symbol.

\noindent
\begin{minipage}{\linewidth}\vspace{0.5em}
\begin{lstlisting}[language=lisa, frame=single]
object MyTheory extends lisa.Main {
  val x = variable[Ind]
  val f = variable[Ind >>: Ind]
  val P = variable[Ind >>: Prop]
}
\end{lstlisting}
\end{minipage}

\noindent
which begins to reveal something about objects in Lisa.
\lstinline|variable[Ind]| indicates a variable of sort \lstinline|Ind|, the sort
of \emph{individuals}. \lstinline|variable[Ind >>: Ind]| indicates an
\emph{uninterpreted} function symbol taking a single argument of sort
\lstinline|Ind| and returning an object of sort \lstinline|Ind|. Finally,
\lstinline|variable[Ind >>: Prop]| indicates an \emph{uninterpreted} predicate
symbol taking a single argument of sort \lstinline|Ind| and returning a formula
(of sort \lstinline|Prop|, for \emph{propositions}).

Uninterpreted in this context means that the function or predicate symbol has no
intrinsic meaning, it is an arbitrary symbol of its type. In fact, we can choose
to instantiate such variables with concrete functions and predicates later.

The symbol \lstinline|>>:| is right associative, so for example
\lstinline|function[Ind >>: Ind >>: Ind]| would indicate a function symbol
taking two arguments of sort \lstinline|Ind| and returning an object of sort
\lstinline|Ind|.

\needspace{10\baselineskip}
We can now state the theorem and start the proof:

\noindent
\begin{minipage}{\linewidth}\vspace{0.5em}
\begin{lstlisting}[language=lisa, frame=single]
object MyTheoryName extends lisa.Main {
  val x = variable
  val f = function[1]
  val P = predicate[1]

  val fixedPointDoubleApplication = Theorem(
    ∀(x, P(x) ==> P(f(x))) |- P(x) ==> P(f(f(x)))
  ) {
    sorry  // your proof goes here
  }
}
\end{lstlisting}
\end{minipage}
%
The theorem will be named \lstinline|fixedPointDoubleApplication| automatically,
extracting the name given to its identifier. The proof itself is built using a
sequence of proof steps, each of which update the state of the currently open
proof.

\noindent
\begin{minipage}{\linewidth}\vspace{0.5em}
\begin{lstlisting}[language=lisa, frame=single]
object MyTheoryName extends lisa.Main {
  val x = variable
  val f = function[1]
  val P = predicate[1]

  val fixedPointDoubleApplication = Theorem(
    ∀(x, P(x) ==> P(f(x))) |- P(x) ==> P(f(f(x)))
  ) {
    assume(∀(x, P(x) ==> P(f(x))))

    val step1 = have(P(x) ==> P(f(x))) by InstantiateForall
    val step2 = have(P(f(x)) ==> P(f(f(x)))) by InstantiateForall

    have(thesis) by Tautology.from(step1, step2)
  }
}
\end{lstlisting}
\end{minipage}

\needspace{4\baselineskip}
First, we use the \lstinline|assume| construct in line 9. This tells Lisa that
the assumed formula is understood as \emph{implicitly} being on the left-hand
side of \emph{every} statement in the rest of the proof.

Then, we need to instantiate the quantified formula twice using an instantiation
tactic. In lines 11 and 12, we use \lstinline|have| to state that a formula or
sequent is true (given the assumption made with \lstinline|assume|), and that the
proof of this is produced by the tactic \lstinline|InstantiateForall|.

We'll see more about the interface of a tactic later. To be able to reuse
intermediate steps at any point later, we also name and assign the intermediate
steps to a variable.

Finally, the last line of the proof says that the conclusion of the theorem
itself, always denoted \lstinline|thesis| locally, can be proven using the
tactic \lstinline|Tautology| and the two intermediate steps we reached.

\lstinline|Tautology| is a tactic that proves propositional consequences. It
implements a complete decision procedure for propositional logic, and is
described further in \Cref{tact:Tautology}.

Lisa's mathematical library is based on set theory, so you can also use
set-theoretic primitives in theorems:

\noindent
\begin{minipage}{\linewidth}\vspace{0.5em}
  \begin{lstlisting}[language=lisa, frame=single]
val emptySetIsASubset = Theorem(∅ ⊆ x) {
  have((y ∈ ∅) ==> (y ∈ x)) by Tautology.from(emptySetAxiom of (x := y))
  val rhs = thenHave (∀(y, (y ∈ ∅) ==> (y ∈ x))) by RightForall
  have(thesis) by Tautology.from(subsetAxiom of (x := ∅, y := x), rhs)
}
\end{lstlisting}
\end{minipage}

We see a number of new constructs in this example. \lstinline|RightForall| is
another tactic (in fact it corresponds to a core deduction rule of the kernel)
that introduces a universal quantifier around a formula, if the bound variable is not free
somewhere else in the sequent.

\needspace{5\baselineskip}
We also see another construct in line 3: \lstinline|thenHave|. It is similar to
\lstinline|have|, but it will automatically use the previous statement as the
premise for the applied tactic. Formally,

\noindent
\begin{minipage}{\linewidth}\vspace{1em}
  \begin{lstlisting}[language=lisa, frame=single, numbers=none]
    have(X) by Tactic1
    thenHave (Y) by Tactic2
\end{lstlisting}
\end{minipage}
%
is equivalent to

\noindent
\begin{minipage}{\linewidth}\vspace{1em}
  \begin{lstlisting}[language=lisa, frame=single, numbers=none]
    val s1 = have(X) by Tactic1
    have(Y) by Tactic2(s1)
\end{lstlisting}
\end{minipage}
\lstinline|thenHave| allows us to not give a name to every step when we're doing
reasoning linearly, transforming step after step. 

Finally, in lines 2 and 4, we see that tactics can refer not only to steps of the
current proof, but also to previously proven theorems and axioms, such as
\lstinline|emptySetAxiom|. The \lstinline|of| keyword indicates the axiom (or
step) is instantiated in a particular way. For example:

\noindent
\begin{minipage}{\linewidth}\vspace{1em}
  \begin{lstlisting}[language=lisa, frame=single, numbers=none]
    emptySetAxiom             // ==  |- !(x ∈ ∅)
    emptySetAxiom of (x := y) // ==  |- !(y ∈ ∅)
\end{lstlisting}
\end{minipage}

Lisa also allows the introduction of definitions. There are essentially two
kinds of definitions, \emph{aliases}, and definition via \emph{unique
existence}. An alias defines a constant, a function, or a predicate as being
equal (or equivalent) to a given term or formula. For example,

\noindent
\begin{minipage}{\linewidth}\vspace{1em}
  \begin{lstlisting}[language=lisa, frame=single, numbers=none]
  val successor = DEF(λ(x, x ∪ singleton(x)))
\end{lstlisting}
\end{minipage}
defines the function symbol \lstinline|successor| as the function taking a
single argument $x$ and mapping it to the element $x \cup \lbrace x \rbrace$
\footnote{This corresponds to the traditional encoding of the successor function
for natural numbers in set theory.}.

The second way of defining an object is more complicated and involve proving the existence and uniqueness of an object. This is detailed in \Cref{chapt:kernel}.

You can now try to run the theory file you just wrote and verify if you made a mistake. To do so again do \lstinline|> run| in the sbt console and select the number corresponding to your file.
If all the output is green, perfect! If there is an error, it can be either a syntax error reported at compilation or an error in the proof. In both case, the error message can sometimes be cryptic, but it should at least consistently indicates which line of your file is incorrect.

Alternatively, if you are using IntelliJ or VS Code and Metals, you can run your theory file directly in your IDE by clicking either on the green arrow (IntelliJ) or on ``run" (VS Code) next to your main object.

\section{Common Tactics}
\subsubsection*{Restate}

Restate is a tactic that reasons modulo ortholattices, a subtheory of boolean
algebra (see \cite{guilloudFormulaNormalizationsVerification2023} and
\Cref{subsec:equivalencechecker}). It is quite efficient and can prove a lot of
simple propositional transformations, but not everything that is true in
classical logic. In particular, it can't prove that $(a\land b) \lor (a \land c)
\iff a \land (b \lor c)$ is true. It can, however, prove very limited facts
involving equality and quantifiers. Usage:

\begin{lstlisting}[language=lisa]
  have(statement) by Restate
\end{lstlisting}
tries to justify \lstinline|statement| by showing it is equivalent to
\lstinline|True|.

\begin{lstlisting}[language=lisa]
  have(statement) by Restate(premise)
\end{lstlisting}
tries to justify \lstinline|statement| by showing it is equivalent to the
previously proven fact \lstinline|premise|.

\subsubsection*{Tautology}\label{tact:Tautology} 

\lstinline|Tautology| is a propositional solver based upon restate, but
complete. It is able to prove every inference that holds in classical
propositional logic. However, in the worst case its complexity can be
exponential in the size of the formula. Usage:

\begin{lstlisting}[language=lisa]
  have(statement) by Tautology
\end{lstlisting}
Constructs a proof of \lstinline|statement|, if the statement is true and a
proof of it using only classical propositional reasoning exists.

\begin{lstlisting}[language=lisa]
  have(statement) by Tautology.from(premise1, premise2,...)
\end{lstlisting}
Construct a proof of \lstinline|statement| from the previously proven facts
\lstinline|premise1|, \lstinline|premise2|,... using propositional reasoning.

\subsubsection*{RightForall, InstantiateForall}

\lstinline|RightForall| will generalize a statement by quantifying it over free
variables. For example,
\begin{lstlisting}[language=lisa]
  have(P(x)) by ??? // some proof
  thenHave(∀(x, P(x))) by RightForall
\end{lstlisting}

Note that if the sequent contains more than one formula, $x$ cannot appear (it
cannot be \emph{free}) in any formula other than $P(x)$. It can also not appear
in any assumption.

\lstinline|InstantiateForall| does the opposite: given a universally quantified statement, it will specialize it. For example:
\begin{lstlisting}[language=lisa]
  have(∀(x, P(x))) by ???
  thenHave(P(t)) by InstantiateForall
\end{lstlisting}
for any arbitrary term \lstinline|t|.

\subsubsection*{Substitution}

Substitutions allows reasoning by substituting equal terms and equivalent
formulas. Usage:
\begin{lstlisting}[language=lisa]
  have(statement) by Substitution(subst*)(premise)
\end{lstlisting}

\lstinline|subst*| is an arbitrary number of substitutions. Each substitution
rule can be a previously proven fact (or theorem or axiom), or a formula. They
must all be of the form \lstinline|s === t| or \lstinline|A <=> B|, otherwise
the tactic will fail. 

The \lstinline|premise| is a previously proven fact. The tactic will try to show
that \lstinline|statement| can be obtained from \lstinline|premise| by applying
the substitutions from \lstinline|subst|. In its simplest form,
%
\begin{lstlisting}[language=lisa]
  val subst = have(s === t) by ???
  have(P(s)) by ???
  thenHave(P(t)) by Substitution(subst)
\end{lstlisting}

Moreover, \lstinline|Substitution| is also able to  automatically unify and
instantiate subst rules. For example

\begin{lstlisting}[language=lisa]
  val subst = have(g(x, y) === g(y, x)) by ???
  have(P(g(3, 8))) by ???
  thenHave(P(g(8, 3))) by Substitution(subst)
\end{lstlisting}

If a \lstinline|subst| is a formula rather than a proven fact, then it should be
an assumption in the resulting statement. Similarly, if one of the substitution
has an assumption, it should be in the resulting statement. For example,

\begin{lstlisting}[language=lisa]
  val subst = have(A |- Q(s) <=> P(s)) by ???
  have(Q(s) /\ s === f(t)) by ???
  thenHave(A, f(t) === t |- P(s) /\ s === t) 
        by Substitution(subst, f(t) === t)
\end{lstlisting}

\subsection*{File Options}
Some options can be set at the start of a file, which will affect the behaviour
of Lisa. These options are intended for use at a development stage.

\vspace{2em}
\begin{tabularx}{0.9\columnwidth}{|l|X|}
  \lstinline|draft()| & Theorems outside of the current file are assumed to be
  true and not checked for correctness. This can speed up repetitive runs during
  proof drafts. \\[4ex]
  \lstinline|withCache()| & Kernel proofs will be stored in binary files when
  theorems are constructed. On future runs with the option enabled, theorems
  will be constructed from the stored low level proofs. This skips running
  tactics to construct or search for proofs.\\

\end{tabularx}